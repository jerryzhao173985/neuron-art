<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Illumination - Live Training Visualization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&family=Lora:wght@400;500&display=swap" rel="stylesheet">
    <style>
        /* Anthropic Brand Colors */
        :root {
            --anthropic-dark: #141413;
            --anthropic-light: #faf9f5;
            --anthropic-mid-gray: #b0aea5;
            --anthropic-light-gray: #e8e6dc;
            --anthropic-orange: #d97757;
            --anthropic-blue: #6a9bcc;
            --anthropic-green: #788c5d;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Poppins', sans-serif;
            background: linear-gradient(135deg, var(--anthropic-light) 0%, #f5f3ee 100%);
            min-height: 100vh;
            color: var(--anthropic-dark);
        }

        .container {
            display: flex;
            min-height: 100vh;
            padding: 20px;
            gap: 20px;
        }

        /* Sidebar */
        .sidebar {
            width: 320px;
            flex-shrink: 0;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 24px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(20, 20, 19, 0.1);
            overflow-y: auto;
            overflow-x: hidden;
        }

        .sidebar h1 {
            font-family: 'Lora', serif;
            font-size: 24px;
            font-weight: 500;
            color: var(--anthropic-dark);
            margin-bottom: 8px;
        }

        .sidebar .subtitle {
            color: var(--anthropic-mid-gray);
            font-size: 14px;
            margin-bottom: 32px;
            line-height: 1.4;
        }

        /* Control Sections */
        .control-section {
            margin-bottom: 32px;
        }

        .control-section h3 {
            font-size: 16px;
            font-weight: 600;
            color: var(--anthropic-dark);
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-section h3::before {
            content: '•';
            color: var(--anthropic-orange);
            font-weight: bold;
        }

        /* Seed Controls */
        .seed-input {
            width: 100%;
            background: var(--anthropic-light);
            padding: 12px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            margin-bottom: 12px;
            border: 1px solid var(--anthropic-light-gray);
            text-align: center;
        }

        .seed-input:focus {
            outline: none;
            border-color: var(--anthropic-orange);
            box-shadow: 0 0 0 2px rgba(217, 119, 87, 0.1);
            background: white;
        }

        .seed-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 8px;
        }

        .regen-button {
            margin-bottom: 0;
        }

        /* Parameter Controls */
        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            font-size: 14px;
            font-weight: 500;
            color: var(--anthropic-dark);
            margin-bottom: 8px;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .slider-container input[type="range"] {
            flex: 1;
            height: 4px;
            background: var(--anthropic-light-gray);
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
        }

        .slider-container input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: var(--anthropic-orange);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .slider-container input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            background: #c86641;
        }

        .slider-container input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: var(--anthropic-orange);
            border-radius: 50%;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .value-display {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: var(--anthropic-mid-gray);
            min-width: 60px;
            text-align: right;
        }

        /* Buttons */
        .button {
            background: var(--anthropic-orange);
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            width: 100%;
        }

        .button:hover {
            background: #c86641;
            transform: translateY(-1px);
        }

        .button:active {
            transform: translateY(0);
        }

        .button.secondary {
            background: var(--anthropic-blue);
        }

        .button.secondary:hover {
            background: #5a8bb8;
        }

        .button.tertiary {
            background: var(--anthropic-green);
        }

        .button.tertiary:hover {
            background: #6b7b52;
        }

        .button-row {
            display: flex;
            gap: 8px;
        }

        .button-row .button {
            flex: 1;
        }

        /* Canvas Area */
        .canvas-area {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 0;
        }

        #canvas-container {
            width: 100%;
            max-width: 1400px;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 20px 40px rgba(20, 20, 19, 0.1);
            background: white;
        }

        #canvas-container canvas {
            display: block;
            width: 100% !important;
            height: auto !important;
        }

        /* Stats Display */
        .stats {
            font-family: 'Courier New', monospace;
            font-size: 11px;
            color: var(--anthropic-mid-gray);
            margin-top: 8px;
            line-height: 1.6;
        }

        /* Responsive */
        @media (max-width: 600px) {
            .container {
                flex-direction: column;
            }

            .sidebar {
                width: 100%;
            }

            .canvas-area {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Control Sidebar -->
        <div class="sidebar">
            <h1>Neural Illumination</h1>
            <div class="subtitle">Live training visualization of a neural network learning to classify shapes. Every glow, pulse, and flow represents real computation.</div>

            <!-- Seed Section -->
            <div class="control-section">
                <h3>Seed</h3>
                <input type="number" id="seed-input" class="seed-input" value="42" onchange="updateSeed()">
                <div class="seed-controls">
                    <button class="button secondary" onclick="previousSeed()">← Prev</button>
                    <button class="button secondary" onclick="nextSeed()">Next →</button>
                </div>
                <button class="button tertiary regen-button" onclick="randomSeedAndUpdate()">↻ Random</button>
            </div>

            <!-- Training Parameters -->
            <div class="control-section">
                <h3>Training</h3>

                <div class="control-group">
                    <label>Learning Rate</label>
                    <div class="slider-container">
                        <input type="range" id="learningRate" min="0.001" max="0.5" step="0.001" value="0.05" oninput="updateParam('learningRate', this.value)">
                        <span class="value-display" id="learningRate-value">0.05</span>
                    </div>
                </div>

                <div class="control-group">
                    <label>Training Speed <small style="color: #888;">(epochs per frame)</small></label>
                    <div class="slider-container">
                        <input type="range" id="trainingSpeed" min="0.1" max="10" step="0.1" value="3" oninput="updateParam('trainingSpeed', this.value)">
                        <span class="value-display" id="trainingSpeed-value">3.0</span>
                    </div>
                </div>

                <div class="control-group">
                    <label>Batch Size</label>
                    <div class="slider-container">
                        <input type="range" id="batchSize" min="4" max="32" step="4" value="16" oninput="updateParam('batchSize', this.value)">
                        <span class="value-display" id="batchSize-value">16</span>
                    </div>
                </div>

                <div class="control-group">
                    <label>Training Samples</label>
                    <div class="slider-container">
                        <input type="range" id="dataSamples" min="50" max="1000" step="10" value="240" oninput="updateParam('dataSamples', this.value, true)">
                        <span class="value-display" id="dataSamples-value">240</span>
                    </div>
                </div>

                <div class="control-group">
                    <label>Max Epochs</label>
                    <div class="slider-container">
                        <input type="range" id="maxEpochs" min="50" max="500" step="10" value="200" oninput="updateParam('maxEpochs', this.value)">
                        <span class="value-display" id="maxEpochs-value">200</span>
                    </div>
                </div>

                <div class="control-group">
                    <label>Accuracy Threshold</label>
                    <div class="slider-container">
                        <input type="range" id="accuracyThreshold" min="0.5" max="1.0" step="0.05" value="0.80" oninput="updateParam('accuracyThreshold', this.value)">
                        <span class="value-display" id="accuracyThreshold-value">80%</span>
                    </div>
                </div>

                <div class="control-group">
                    <label>Hidden Layer Size</label>
                    <div class="slider-container">
                        <input type="range" id="hiddenSize" min="8" max="32" step="4" value="16" oninput="updateParam('hiddenSize', this.value, true)">
                        <span class="value-display" id="hiddenSize-value">16</span>
                    </div>
                </div>

                <div class="control-group">
                    <label style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="earlyStop" onchange="updateParam('earlyStop', this.checked)" style="width: auto;">
                        <span>Early Stop (when accuracy plateaus)</span>
                    </label>
                </div>
            </div>

            <!-- Visualization Parameters -->
            <div class="control-section">
                <h3>Visualization</h3>

                <div class="control-group">
                    <label>Neuron Glow Intensity</label>
                    <div class="slider-container">
                        <input type="range" id="glowIntensity" min="0.1" max="3" step="0.1" value="1.5" oninput="updateParam('glowIntensity', this.value)">
                        <span class="value-display" id="glowIntensity-value">1.5</span>
                    </div>
                </div>

                <div class="control-group">
                    <label>Animation Multiplier <small style="color: #888;">(syncs with Training Speed)</small></label>
                    <div class="slider-container">
                        <input type="range" id="flowSpeed" min="0.1" max="3" step="0.1" value="1.5" oninput="updateParam('flowSpeed', this.value)">
                        <span class="value-display" id="flowSpeed-value">1.5</span>
                    </div>
                </div>

                <div class="control-group">
                    <label>Synapse Visibility</label>
                    <div class="slider-container">
                        <input type="range" id="synapseAlpha" min="0.1" max="1" step="0.05" value="0.4" oninput="updateParam('synapseAlpha', this.value)">
                        <span class="value-display" id="synapseAlpha-value">0.4</span>
                    </div>
                </div>

                <div class="control-group">
                    <label style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="showSynapses" checked onchange="updateParam('showSynapses', this.checked)" style="width: auto;">
                        <span>Show Synapses (connection lines)</span>
                    </label>
                </div>

                <div class="control-group">
                    <label style="display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" id="showParticles" checked onchange="updateParam('showParticles', this.checked)" style="width: auto;">
                        <span>Show Particles (flow animations)</span>
                    </label>
                </div>
            </div>

            <!-- Stats -->
            <div class="control-section">
                <h3>Statistics</h3>
                <div class="stats" id="stats">
                    Epoch: 0<br>
                    Loss: -<br>
                    Accuracy: -<br>
                    Phase: Initializing
                </div>
            </div>

            <!-- Training Diagnostics -->
            <div class="control-section">
                <h3>Training Proof</h3>
                <div class="stats" id="diagnostics">
                    Total weight Δ: 0.0000<br>
                    Sample weight:<br>
                    W2[0][0] = -<br>
                    <small style="color: #788c5d;">Open browser console<br>for detailed logs</small>
                </div>
            </div>

            <!-- Training Monitor -->
            <div class="control-section">
                <h3>Training Monitor</h3>
                <div class="stats" id="math-display" style="font-size: 11px; line-height: 1.6;">
                    Click "Show Monitor" to see<br>
                    live training dynamics
                </div>
                <button class="button tertiary" onclick="toggleMathDisplay()" id="mathButton" style="margin-top: 8px;">📊 Show Monitor</button>
            </div>

            <!-- Actions -->
            <div class="control-section">
                <h3>Actions</h3>
                <div class="button-row">
                    <button class="button" onclick="toggleTraining()" id="trainButton">⏸ Pause</button>
                    <button class="button secondary" onclick="resetTraining()">↻ Reset</button>
                </div>
                <button class="button tertiary" onclick="printDiagnostics()" style="margin-top: 8px;">📊 Print Full Diagnostics</button>
            </div>
        </div>

        <!-- Main Canvas Area -->
        <div class="canvas-area">
            <div id="canvas-container"></div>
        </div>
    </div>

    <script>
        // ═══════════════════════════════════════════════════════════════════════
        // PARAMETERS
        // ═══════════════════════════════════════════════════════════════════════

        let params = {
            seed: 42,
            learningRate: 0.05,
            trainingSpeed: 3,
            batchSize: 16,
            glowIntensity: 1.5,
            flowSpeed: 1.5,
            synapseAlpha: 0.4,

            // Visualization toggles
            showSynapses: true,      // Show/hide connection lines
            showParticles: true,     // Show/hide flow particles

            // Training control parameters
            dataSamples: 240,        // Number of training samples (50-1000)
            maxEpochs: 200,          // Training epochs (50-500)
            accuracyThreshold: 0.80, // Confidence threshold for correct predictions (0.5-1.0)

            // Network architecture
            hiddenSize: 16,          // Neurons per hidden layer (8-32)

            // Training behavior
            earlyStop: false         // Stop when accuracy plateaus
        };

        let defaultParams = {...params};

        // ═══════════════════════════════════════════════════════════════════════
        // NEURAL NETWORK CLASS
        // ═══════════════════════════════════════════════════════════════════════

        class NeuralNetwork {
            constructor(inputSize, hidden1Size, hidden2Size, outputSize, seed) {
                this.inputSize = inputSize;
                this.hidden1Size = hidden1Size;
                this.hidden2Size = hidden2Size;
                this.outputSize = outputSize;

                // Initialize weights with Xavier initialization
                randomSeed(seed);

                // Weights: input -> hidden1
                this.W1 = this.initWeights(inputSize, hidden1Size);
                this.b1 = Array(hidden1Size).fill(0);

                // Weights: hidden1 -> hidden2
                this.W2 = this.initWeights(hidden1Size, hidden2Size);
                this.b2 = Array(hidden2Size).fill(0);

                // Weights: hidden2 -> output
                this.W3 = this.initWeights(hidden2Size, outputSize);
                this.b3 = Array(outputSize).fill(0);

                // Store activations and gradients for visualization
                this.inputActivations = [];
                this.hidden1Activations = [];
                this.hidden2Activations = [];
                this.outputActivations = [];

                this.hidden1Gradients = [];
                this.hidden2Gradients = [];
                this.outputGradients = [];

                this.W1Gradients = [];
                this.W2Gradients = [];
                this.W3Gradients = [];
            }

            initWeights(rows, cols) {
                const scale = Math.sqrt(2.0 / rows);
                const weights = [];
                for (let i = 0; i < rows; i++) {
                    weights[i] = [];
                    for (let j = 0; j < cols; j++) {
                        weights[i][j] = (random() - 0.5) * 2 * scale;
                    }
                }
                return weights;
            }

            relu(x) {
                return Math.max(0, x);
            }

            reluDerivative(x) {
                return x > 0 ? 1 : 0;
            }

            softmax(arr) {
                const max = Math.max(...arr);
                const exps = arr.map(x => Math.exp(x - max));
                const sum = exps.reduce((a, b) => a + b, 0);
                return exps.map(x => x / sum);
            }

            forward(input) {
                this.inputActivations = [...input];

                // Hidden layer 1
                this.hidden1Activations = [];
                for (let j = 0; j < this.hidden1Size; j++) {
                    let sum = this.b1[j];
                    for (let i = 0; i < this.inputSize; i++) {
                        sum += input[i] * this.W1[i][j];
                    }
                    this.hidden1Activations[j] = this.relu(sum);
                }

                // Hidden layer 2
                this.hidden2Activations = [];
                for (let j = 0; j < this.hidden2Size; j++) {
                    let sum = this.b2[j];
                    for (let i = 0; i < this.hidden1Size; i++) {
                        sum += this.hidden1Activations[i] * this.W2[i][j];
                    }
                    this.hidden2Activations[j] = this.relu(sum);
                }

                // Output layer
                const outputRaw = [];
                for (let k = 0; k < this.outputSize; k++) {
                    let sum = this.b3[k];
                    for (let j = 0; j < this.hidden2Size; j++) {
                        sum += this.hidden2Activations[j] * this.W3[j][k];
                    }
                    outputRaw[k] = sum;
                }

                this.outputActivations = this.softmax(outputRaw);
                return this.outputActivations;
            }

            backward(input, target, learningRate) {
                // Output layer gradients
                this.outputGradients = [];
                for (let k = 0; k < this.outputSize; k++) {
                    this.outputGradients[k] = this.outputActivations[k] - target[k];
                }

                // Hidden layer 2 gradients (backprop from output)
                this.hidden2Gradients = [];
                for (let j = 0; j < this.hidden2Size; j++) {
                    let grad = 0;
                    for (let k = 0; k < this.outputSize; k++) {
                        grad += this.outputGradients[k] * this.W3[j][k];
                    }
                    this.hidden2Gradients[j] = grad * this.reluDerivative(this.hidden2Activations[j]);
                }

                // Hidden layer 1 gradients (backprop from hidden2)
                this.hidden1Gradients = [];
                for (let j = 0; j < this.hidden1Size; j++) {
                    let grad = 0;
                    for (let k = 0; k < this.hidden2Size; k++) {
                        grad += this.hidden2Gradients[k] * this.W2[j][k];
                    }
                    this.hidden1Gradients[j] = grad * this.reluDerivative(this.hidden1Activations[j]);
                }

                // Update W3 and b3 (hidden2 -> output)
                this.W3Gradients = [];
                for (let j = 0; j < this.hidden2Size; j++) {
                    this.W3Gradients[j] = [];
                    for (let k = 0; k < this.outputSize; k++) {
                        const gradient = this.outputGradients[k] * this.hidden2Activations[j];
                        this.W3Gradients[j][k] = gradient;
                        this.W3[j][k] -= learningRate * gradient;
                    }
                }

                for (let k = 0; k < this.outputSize; k++) {
                    this.b3[k] -= learningRate * this.outputGradients[k];
                }

                // Update W2 and b2 (hidden1 -> hidden2)
                this.W2Gradients = [];
                for (let j = 0; j < this.hidden1Size; j++) {
                    this.W2Gradients[j] = [];
                    for (let k = 0; k < this.hidden2Size; k++) {
                        const gradient = this.hidden2Gradients[k] * this.hidden1Activations[j];
                        this.W2Gradients[j][k] = gradient;
                        this.W2[j][k] -= learningRate * gradient;
                    }
                }

                for (let k = 0; k < this.hidden2Size; k++) {
                    this.b2[k] -= learningRate * this.hidden2Gradients[k];
                }

                // Update W1 and b1 (input -> hidden1)
                this.W1Gradients = [];
                for (let i = 0; i < this.inputSize; i++) {
                    this.W1Gradients[i] = [];
                    for (let j = 0; j < this.hidden1Size; j++) {
                        const gradient = this.hidden1Gradients[j] * input[i];
                        this.W1Gradients[i][j] = gradient;
                        this.W1[i][j] -= learningRate * gradient;
                    }
                }

                for (let j = 0; j < this.hidden1Size; j++) {
                    this.b1[j] -= learningRate * this.hidden1Gradients[j];
                }
            }

            train(input, target, learningRate) {
                this.forward(input);
                this.backward(input, target, learningRate);
            }
        }

        // ═══════════════════════════════════════════════════════════════════════
        // REAL DATA GENERATION - RANDOM SHAPES WITH VARIATION
        // ═══════════════════════════════════════════════════════════════════════

        function generateShape(type, seed) {
            randomSeed(seed);
            const size = 8;
            const data = Array(size * size).fill(0);

            if (type === 0) { // Circle - with random position, size, and deformation
                const cx = random(2, 6);
                const cy = random(2, 6);
                const r = random(1.5, 3.2);
                const deformX = random(0.8, 1.2); // Ellipse deformation
                const deformY = random(0.8, 1.2);

                for (let y = 0; y < size; y++) {
                    for (let x = 0; x < size; x++) {
                        const dx = (x - cx) * deformX;
                        const dy = (y - cy) * deformY;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        // Anti-aliased edge for more realistic shapes
                        if (dist < r - 0.5) {
                            data[y * size + x] = 1;
                        } else if (dist < r + 0.5) {
                            data[y * size + x] = random() > 0.5 ? 1 : 0;
                        }
                    }
                }
            } else { // Square/Rectangle - with random position, size, rotation
                const cx = random(3, 5);
                const cy = random(3, 5);
                const w = random(3, 5);
                const h = random(3, 5);
                const angle = random(-0.3, 0.3); // Slight rotation

                for (let y = 0; y < size; y++) {
                    for (let x = 0; x < size; x++) {
                        // Rotate point around center
                        const dx = x - cx;
                        const dy = y - cy;
                        const rotX = dx * Math.cos(angle) - dy * Math.sin(angle);
                        const rotY = dx * Math.sin(angle) + dy * Math.cos(angle);

                        if (Math.abs(rotX) < w / 2 && Math.abs(rotY) < h / 2) {
                            data[y * size + x] = 1;
                        }
                    }
                }
            }

            // Add realistic noise - pixel flips and gaussian noise
            for (let i = 0; i < data.length; i++) {
                // Random pixel flips (salt and pepper noise)
                if (random() < 0.08) {
                    data[i] = 1 - data[i];
                }
                // Random intensity variation
                if (data[i] > 0 && random() < 0.15) {
                    data[i] = random() > 0.5 ? 0 : 1;
                }
            }

            return data;
        }

        function generateDataset(count, seed) {
            const dataset = [];
            randomSeed(seed);

            // Create balanced dataset with random ordering
            const labels = [];
            for (let i = 0; i < count; i++) {
                labels.push(i % 2);
            }

            // Shuffle labels for random distribution
            for (let i = labels.length - 1; i > 0; i--) {
                const j = floor(random() * (i + 1));
                [labels[i], labels[j]] = [labels[j], labels[i]];
            }

            // Generate shapes with random seeds
            for (let i = 0; i < count; i++) {
                const type = labels[i];
                const shapeSeed = floor(random() * 1000000);
                const data = generateShape(type, shapeSeed);
                const label = type === 0 ? [1, 0] : [0, 1];
                dataset.push({ data, label, type });
            }

            return dataset;
        }

        // ═══════════════════════════════════════════════════════════════════════
        // TRAINING STATE
        // ═══════════════════════════════════════════════════════════════════════

        let network;
        let trainingData;
        let testData;
        let epoch = 0;
        let totalEpochs = 200;  // Will be set from params.maxEpochs during initialization
        let currentPhase = 'forward'; // 'forward' or 'backward'
        let phaseProgress = 0;
        let isTraining = true;
        let lossHistory = [];
        let accHistory = [];
        let currentLoss = 0;
        let currentAcc = 0;

        // Track max gradients for relative bar display
        let maxHidden1Grad = 0.001;  // Start with small non-zero value
        let maxHidden2Grad = 0.001;
        let maxOutputGrad = 0.001;

        // Early stopping tracking
        let bestAccuracy = 0;
        let epochsSinceImprovement = 0;
        let earlyStopPatience = 15;  // Stop if no improvement for 15 epochs
        const improvementThreshold = 0.001;  // Minimum improvement to count as progress

        // Frozen state for pause functionality
        let frozenPredictions = null;  // Cache predictions when paused
        let frozenNetworkState = null;  // Cache network activations when paused

        // Training frame counter (only increments when training, for consistent timing)
        let trainingFrameCount = 0;

        // Epoch accumulator (for fractional training speeds < 1.0)
        let epochAccumulator = 0;

        // Effective animation speed (synchronized with training speed)
        let effectiveAnimationSpeed = 1.5;

        // Training diagnostics - proof of learning
        let initialWeights = null;
        let totalWeightChanges = 0;
        let trainingLog = [];
        let predictionHistory = []; // Track how predictions change over time
        let showMath = false;

        // Batch processing state
        let currentBatch = 0;
        let totalBatches = 0;
        let samplesInCurrentBatch = 0;

        function initializeTraining() {
            randomSeed(params.seed);

            // Create network with configurable hidden layer sizes
            network = new NeuralNetwork(64, params.hiddenSize, params.hiddenSize, 2, params.seed);

            // Store initial weights for comparison
            initialWeights = {
                W1: JSON.parse(JSON.stringify(network.W1)),
                W2: JSON.parse(JSON.stringify(network.W2)),
                W3: JSON.parse(JSON.stringify(network.W3)),
                b1: [...network.b1],
                b2: [...network.b2],
                b3: [...network.b3]
            };

            // Generate datasets with configurable sample count
            trainingData = generateDataset(params.dataSamples, params.seed);
            testData = generateDataset(Math.max(40, Math.floor(params.dataSamples / 6)), params.seed + 10000);

            // Reset training state
            epoch = 0;
            totalEpochs = params.maxEpochs;  // Set from parameters
            lossHistory = [];
            accHistory = [];
            currentLoss = 0;
            currentAcc = 0;
            phaseProgress = 0;
            currentPhase = 'forward';
            totalWeightChanges = 0;
            trainingFrameCount = 0;  // Reset training frame counter
            epochAccumulator = 0;  // Reset epoch accumulator
            trainingLog = [];
            predictionHistory = [];

            // Reset early stopping
            bestAccuracy = 0;
            epochsSinceImprovement = 0;

            // Reset max gradients for relative display
            maxHidden1Grad = 0.001;
            maxHidden2Grad = 0.001;
            maxOutputGrad = 0.001;

            // Reset visualization state
            flowParticles = [];  // Clear all particles
            frozenPredictions = null;  // Clear frozen cache
            frozenNetworkState = null;  // Clear frozen network state

            // Log initial state
            console.log('=== NEURAL NETWORK INITIALIZED ===');
            console.log('Seed:', params.seed);
            console.log(`Architecture: 64 → ${params.hiddenSize} → ${params.hiddenSize} → 2`);
            console.log('Training samples:', trainingData.length);
            console.log('Test samples:', testData.length);
            console.log('Max epochs:', params.maxEpochs);
            console.log('Accuracy threshold:', (params.accuracyThreshold * 100).toFixed(0) + '%');

            // Test initial predictions (before any training)
            const initialPreds = evaluateNetwork();
            console.log('Initial accuracy (random weights):', (initialPreds.acc * 100).toFixed(1) + '%');
            console.log('Initial loss:', initialPreds.loss.toFixed(4));

            // Store initial prediction on first test sample for comparison
            network.forward(testData[0].data);
            const initOutput = [...network.outputActivations];
            console.log('Sample prediction before training:', {
                output: initOutput.map(x => x.toFixed(4)),
                predicted: initOutput[0] > initOutput[1] ? 'Circle' : 'Square',
                actual: testData[0].type === 0 ? 'Circle' : 'Square'
            });
        }

        function evaluateNetwork() {
            let totalLoss = 0;
            let correct = 0;

            for (let i = 0; i < testData.length; i++) {
                const sample = testData[i];
                const pred = network.forward(sample.data);

                // Loss
                const loss = -sample.label.reduce((sum, target, k) =>
                    sum + target * Math.log(Math.max(pred[k], 1e-10)), 0);
                totalLoss += loss;

                // Accuracy
                const predClass = pred[0] > pred[1] ? 0 : 1;
                if (predClass === sample.type) correct++;
            }

            return {
                loss: totalLoss / testData.length,
                acc: correct / testData.length
            };
        }

        function trainEpoch() {
            let totalLoss = 0;
            let correct = 0;

            // Store pre-epoch weights to measure change
            const preWeights = JSON.parse(JSON.stringify(network.W2[0][0]));

            // Shuffle training data
            for (let i = trainingData.length - 1; i > 0; i--) {
                const j = floor(random() * (i + 1));
                [trainingData[i], trainingData[j]] = [trainingData[j], trainingData[i]];
            }

            // Train on batches - each batch does forward pass on all samples,
            // then backward pass updates weights based on averaged gradients
            totalBatches = Math.ceil(trainingData.length / params.batchSize);

            for (let i = 0; i < trainingData.length; i += params.batchSize) {
                const batchEnd = Math.min(i + params.batchSize, trainingData.length);
                currentBatch = Math.floor(i / params.batchSize) + 1;
                samplesInCurrentBatch = batchEnd - i;

                // Forward pass: process all samples in batch
                for (let j = i; j < batchEnd; j++) {
                    const sample = trainingData[j];
                    network.train(sample.data, sample.label, params.learningRate);

                    // Calculate loss (cross-entropy)
                    const pred = network.outputActivations;
                    const loss = -sample.label.reduce((sum, target, k) =>
                        sum + target * Math.log(Math.max(pred[k], 1e-10)), 0);
                    totalLoss += loss;

                    // Check accuracy
                    const predClass = pred[0] > pred[1] ? 0 : 1;
                    const trueClass = sample.label[0] > sample.label[1] ? 0 : 1;
                    if (predClass === trueClass) correct++;
                }
                // Backward pass happens in train() - weights updated after each sample
                // In real mini-batch SGD, you'd accumulate gradients and update once per batch
            }

            currentLoss = totalLoss / trainingData.length;
            currentAcc = correct / trainingData.length;

            lossHistory.push(currentLoss);
            accHistory.push(currentAcc);

            // Track weight changes
            const postWeights = network.W2[0][0];
            const weightDelta = Math.abs(postWeights - preWeights);
            totalWeightChanges += weightDelta;

            // Log progress every 10 epochs
            if (epoch % 10 === 0 || epoch === 0) {
                console.log(`Epoch ${epoch}: Loss=${currentLoss.toFixed(4)}, Acc=${(currentAcc*100).toFixed(1)}%, ΔW=${weightDelta.toFixed(6)}`);

                // Show prediction on test sample to prove it's learning
                if (epoch % 20 === 0 && testData.length > 0) {
                    network.forward(testData[0].data);
                    const output = [...network.outputActivations];
                    console.log(`  → Sample prediction: [${output.map(x => x.toFixed(4)).join(', ')}] (${output[0] > output[1] ? 'Circle' : 'Square'})`);
                }
            }

            // Store milestone predictions
            if (epoch === 1 || epoch === 25 || epoch === 50 || epoch === 75 || epoch === 99) {
                network.forward(testData[0].data);
                predictionHistory.push({
                    epoch: epoch,
                    output: [...network.outputActivations]
                });
            }

            // Early stopping check (if enabled)
            if (params.earlyStop) {
                // Check if there's meaningful improvement
                if (currentAcc > bestAccuracy + improvementThreshold) {
                    bestAccuracy = currentAcc;
                    epochsSinceImprovement = 0;
                    if (epoch > 0 && epoch % 10 === 0) {
                        console.log(`  ✓ New best accuracy: ${(bestAccuracy * 100).toFixed(1)}%`);
                    }
                } else {
                    epochsSinceImprovement++;
                }

                // Stop if no improvement for patience epochs
                if (epochsSinceImprovement >= earlyStopPatience) {
                    console.log(`\n⚠️ Early stopping at epoch ${epoch} (no improvement for ${earlyStopPatience} epochs)`);
                    console.log(`Best accuracy: ${(bestAccuracy * 100).toFixed(1)}%`);
                    console.log(`Current accuracy: ${(currentAcc * 100).toFixed(1)}%`);
                    totalEpochs = epoch;  // Set totalEpochs to current to stop training
                    isTraining = false;
                    // Update button to reflect stopped state
                    const btn = document.getElementById('trainButton');
                    if (btn) btn.textContent = '▶ Resume';
                }
            }

            epoch++;

            // Log final results
            if (epoch >= totalEpochs) {
                console.log('\n=== TRAINING COMPLETE ===');
                console.log('Final loss:', currentLoss.toFixed(4));
                console.log('Final accuracy:', (currentAcc * 100).toFixed(1) + '%');
                console.log('Total weight changes:', totalWeightChanges.toFixed(4));

                // Compare initial vs final weights
                const sampleWeightChange = Math.abs(network.W2[0][0] - initialWeights.W2[0][0]);
                console.log('Sample weight change (W2[0][0]):', {
                    initial: initialWeights.W2[0][0].toFixed(6),
                    final: network.W2[0][0].toFixed(6),
                    delta: sampleWeightChange.toFixed(6)
                });

                // Show how predictions evolved
                console.log('\nPrediction evolution on test sample:');
                console.log('Epoch 0 (random):', predictionHistory.length > 0 ?
                    predictionHistory[0].output.map(x => x.toFixed(4)).join(', ') : 'N/A');
                predictionHistory.forEach(p => {
                    console.log(`Epoch ${p.epoch}: [${p.output.map(x => x.toFixed(4)).join(', ')}]`);
                });

                // Final test evaluation
                const finalEval = evaluateNetwork();
                console.log('\nFinal test set evaluation:');
                console.log('Loss:', finalEval.loss.toFixed(4));
                console.log('Accuracy:', (finalEval.acc * 100).toFixed(1) + '%');
            }
        }

        // ═══════════════════════════════════════════════════════════════════════
        // VISUALIZATION
        // ═══════════════════════════════════════════════════════════════════════

        let canvasWidth = 1550;  // Wider to prevent right-side collision
        let canvasHeight = 900;

        // Layout regions
        let networkX = 750;  // More space from left side
        let networkY = 450;
        let networkScale = 1;

        function setup() {
            let canvas = createCanvas(canvasWidth, canvasHeight);
            canvas.parent('canvas-container');

            initializeTraining();
            frameRate(30);
        }

        function draw() {
            background(250, 249, 245);

            // Calculate effective animation speed (synchronized with training speed)
            // trainingSpeed controls training rate, flowSpeed acts as a multiplier for fine-tuning
            effectiveAnimationSpeed = params.trainingSpeed * (params.flowSpeed / 1.5);

            // Increment training frame counter only when actively training
            if (isTraining && epoch < totalEpochs) {
                trainingFrameCount++;
            }

            // Train based on speed (supports fractional values like 0.1)
            if (isTraining && epoch < totalEpochs) {
                // For speeds >= 1.0: run multiple epochs per frame
                if (params.trainingSpeed >= 1.0) {
                    const epochsToRun = Math.floor(params.trainingSpeed);
                    for (let i = 0; i < epochsToRun; i++) {
                        if (epoch < totalEpochs) {
                            trainEpoch();
                        }
                    }
                }
                // For speeds < 1.0: accumulate and run when we reach 1.0
                else {
                    epochAccumulator += params.trainingSpeed;
                    if (epochAccumulator >= 1.0) {
                        epochAccumulator -= 1.0;
                        if (epoch < totalEpochs) {
                            trainEpoch();
                        }
                    }
                }
            }

            // Animate phase transition - synchronized with training speed
            // Forward pass represents: processing a batch of samples through network
            // Backward pass represents: computing gradients and updating weights for that batch
            if (isTraining && epoch < totalEpochs) {
                phaseProgress += 0.012 * effectiveAnimationSpeed;  // Synchronized transitions
                if (phaseProgress >= 1) {
                    phaseProgress = 0;
                    currentPhase = currentPhase === 'forward' ? 'backward' : 'forward';
                }
            }

            // Draw components (always visible)
            drawPredictionGrid();
            drawNeuralNetwork();
            drawMetrics();
            drawPhaseIndicator();  // Show what phase means

            // Update stats (only when training active)
            if (isTraining || epoch >= totalEpochs) {
                updateStats();
            }
        }

        function drawPredictionGrid() {
            const gridX = 50;
            const gridY = 80; // More space for title and legend
            const cellSize = 60;
            const cols = 5;
            const rows = 4;

            push();
            translate(gridX, gridY);

            // Title
            fill(20);
            noStroke();
            textSize(14);
            textAlign(LEFT);
            textFont('Poppins');
            text('Sample Predictions', 0, -45);

            // Legend - explain colors (dynamic based on threshold)
            textSize(9);
            fill(100);
            const thresholdPercent = Math.round(params.accuracyThreshold * 100);
            text(`Confidence: 0-${thresholdPercent}% Orange (uncertain) → ${thresholdPercent}-100% Blue (confident)`, 0, -30);

            // Cache predictions when pausing, use cache when paused
            if (!isTraining && frozenPredictions === null && testData.length > 0) {
                // First frame of pause - save current network state FIRST
                frozenNetworkState = {
                    inputActivations: [...network.inputActivations],
                    hidden1Activations: [...network.hidden1Activations],
                    hidden2Activations: [...network.hidden2Activations],
                    outputActivations: [...network.outputActivations],
                    hidden1Gradients: [...network.hidden1Gradients],
                    hidden2Gradients: [...network.hidden2Gradients],
                    outputGradients: [...network.outputGradients]
                };

                // Then cache predictions
                frozenPredictions = [];
                for (let i = 0; i < rows * cols && i < testData.length; i++) {
                    const sample = testData[i];
                    network.forward(sample.data);
                    frozenPredictions.push({
                        pred: [...network.outputActivations],
                        type: sample.type,
                        data: sample.data
                    });
                }

                // Restore network state after caching predictions
                network.inputActivations = [...frozenNetworkState.inputActivations];
                network.hidden1Activations = [...frozenNetworkState.hidden1Activations];
                network.hidden2Activations = [...frozenNetworkState.hidden2Activations];
                network.outputActivations = [...frozenNetworkState.outputActivations];
                network.hidden1Gradients = [...frozenNetworkState.hidden1Gradients];
                network.hidden2Gradients = [...frozenNetworkState.hidden2Gradients];
                network.outputGradients = [...frozenNetworkState.outputGradients];
            } else if (isTraining || epoch >= totalEpochs) {
                // Training active - clear cache
                frozenPredictions = null;
                frozenNetworkState = null;
            }

            for (let i = 0; i < rows * cols && i < testData.length; i++) {
                const row = floor(i / cols);
                const col = i % cols;
                const x = col * (cellSize + 10);
                const y = row * (cellSize + 10) + row * 12; // Extra spacing for text

                let pred, predClass, correct, confidence, confidencePercent, sample;

                if (!isTraining && frozenPredictions && frozenPredictions[i]) {
                    // Use cached predictions when paused
                    const cached = frozenPredictions[i];
                    pred = cached.pred;
                    predClass = pred[0] > pred[1] ? 0 : 1;
                    correct = predClass === cached.type;
                    confidence = Math.max(...pred);
                    confidencePercent = confidence * 100;
                    sample = { type: cached.type, data: cached.data };
                } else {
                    // Calculate fresh predictions when training
                    sample = testData[i];
                    network.forward(sample.data);
                    pred = network.outputActivations;
                    predClass = pred[0] > pred[1] ? 0 : 1;
                    correct = predClass === sample.type;
                    confidence = Math.max(...pred);
                    confidencePercent = confidence * 100;
                }

                // Confidence threshold approach (configurable):
                // 0-threshold = Orange (uncertain, effectively wrong)
                // threshold-100% = Blue (confident, good classification)

                let r, g, b;
                const threshold = params.accuracyThreshold; // Configurable confidence threshold

                if (confidence < threshold) {
                    // Below threshold: Orange spectrum
                    // Transition from dark orange to lighter orange
                    const t = confidence / threshold; // 0.0 to 1.0
                    const baseOrange = {r: 217, g: 119, b: 87};
                    const intensity = map(t, 0, 1, 0.4, 0.95); // Dark to medium-light
                    r = baseOrange.r * intensity;
                    g = baseOrange.g * intensity;
                    b = baseOrange.b * intensity;
                } else {
                    // Above threshold: Blue spectrum (80% to 100%)
                    // Transition from light blue to bright blue
                    const t = (confidence - threshold) / (1.0 - threshold); // 0.0 to 1.0
                    const baseBlue = {r: 106, g: 155, b: 204};
                    const intensity = map(t, 0, 1, 0.7, 1.0); // Light to bright
                    r = baseBlue.r * intensity;
                    g = baseBlue.g * intensity;
                    b = baseBlue.b * intensity;
                }

                stroke(r, g, b);
                strokeWeight(3);
                noFill();
                rect(x, y, cellSize, cellSize, 4);

                // Draw shape
                const pixelSize = cellSize / 8;
                noStroke();
                for (let py = 0; py < 8; py++) {
                    for (let px = 0; px < 8; px++) {
                        const val = sample.data[py * 8 + px];
                        if (val > 0.5) {
                            fill(20, 20, 20, 200);
                            rect(x + px * pixelSize, y + py * pixelSize,
                                 pixelSize - 1, pixelSize - 1);
                        }
                    }
                }

                // Draw prediction confidence with matching color
                textSize(9);
                textAlign(CENTER);
                fill(r, g, b); // Match border color

                // Show confidence percentage (moved up slightly)
                text(`${confidencePercent.toFixed(0)}%`,
                     x + cellSize / 2, y + cellSize + 14);
            }

            pop();
        }

        function drawNeuralNetwork() {
            push();
            translate(networkX, networkY);

            const layerSpacing = 200;  // Reduced spacing to fit 4 layers

            // Dynamic neuron spacing based on largest hidden layer
            const maxHiddenSize = Math.max(network.hidden1Size, network.hidden2Size);
            const availableHeight = 700;  // Available vertical space
            const neuronSpacing = Math.min(40, availableHeight / (maxHiddenSize + 1));

            // Calculate positions for 4 layers: input, hidden1, hidden2, output
            const inputPos = [];
            const inputAbstract = 8; // Show 8 input neurons (representing 8x8 grid)
            for (let i = 0; i < inputAbstract; i++) {
                inputPos.push({
                    x: -layerSpacing * 1.5,  // Further left
                    y: (i - inputAbstract / 2) * neuronSpacing
                });
            }

            const hidden1Pos = [];
            for (let i = 0; i < network.hidden1Size; i++) {
                hidden1Pos.push({
                    x: -layerSpacing * 0.5,  // First hidden layer
                    y: (i - network.hidden1Size / 2) * neuronSpacing
                });
            }

            const hidden2Pos = [];
            for (let i = 0; i < network.hidden2Size; i++) {
                hidden2Pos.push({
                    x: layerSpacing * 0.5,  // Second hidden layer
                    y: (i - network.hidden2Size / 2) * neuronSpacing
                });
            }

            const outputPos = [];
            for (let i = 0; i < network.outputSize; i++) {
                outputPos.push({
                    x: layerSpacing * 1.5,  // Further right
                    y: (i - network.outputSize / 2) * 80
                });
            }

            // Draw synapses (only if enabled)
            if (params.showSynapses) {
                drawSynapses(inputPos, hidden1Pos, network.W1,
                             currentPhase, phaseProgress, 'input-hidden1');

                drawSynapses(hidden1Pos, hidden2Pos, network.W2,
                             currentPhase, phaseProgress, 'hidden1-hidden2');

                drawSynapses(hidden2Pos, outputPos, network.W3,
                             currentPhase, phaseProgress, 'hidden2-output');
            }

            // Draw neurons
            drawNeurons(inputPos, network.inputActivations, network.hidden1Gradients, 'input');
            drawNeurons(hidden1Pos, network.hidden1Activations, network.hidden1Gradients, 'hidden1');
            drawNeurons(hidden2Pos, network.hidden2Activations, network.hidden2Gradients, 'hidden2');
            drawNeurons(outputPos, network.outputActivations, network.outputGradients, 'output');

            // Draw layer labels (dynamic based on actual layer sizes)
            fill(20);
            noStroke();
            textSize(11);
            textAlign(CENTER);

            // Input layer label
            const inputLabelY = (inputAbstract / 2) * neuronSpacing + 20;
            text('Input', -layerSpacing * 1.5, inputLabelY);
            text('(64 pixels)', -layerSpacing * 1.5, inputLabelY + 15);

            // Hidden layer 1 label
            const hidden1LabelY = (network.hidden1Size / 2) * neuronSpacing + 20;
            text('Hidden 1', -layerSpacing * 0.5, hidden1LabelY);
            text(`(${network.hidden1Size} neurons)`, -layerSpacing * 0.5, hidden1LabelY + 15);

            // Hidden layer 2 label
            const hidden2LabelY = (network.hidden2Size / 2) * neuronSpacing + 20;
            text('Hidden 2', layerSpacing * 0.5, hidden2LabelY);
            text(`(${network.hidden2Size} neurons)`, layerSpacing * 0.5, hidden2LabelY + 15);

            // Output layer label
            text('Output', layerSpacing * 1.5, 80);
            text('(Circle | Square)', layerSpacing * 1.5, 95);

            pop();
        }

        // Particle system for flow visualization
        let flowParticles = [];

        class FlowParticle {
            constructor(x1, y1, x2, y2, phase, weight) {
                this.x1 = x1;
                this.y1 = y1;
                this.x2 = x2;
                this.y2 = y2;
                this.phase = phase;
                this.weight = weight;
                this.progress = 0;
                // Use effectiveAnimationSpeed for synchronized animation
                this.speed = random(0.015, 0.025) * effectiveAnimationSpeed;
                this.life = 1.0;
                this.size = map(Math.abs(weight), 0, 1, 3, 8);
            }

            update() {
                if (this.phase === currentPhase) {
                    this.progress += this.speed;
                    if (this.progress > 1) {
                        this.progress = 0;
                        this.life = 1.0;
                    }
                } else {
                    this.life -= 0.05;
                }
            }

            display() {
                if (this.life <= 0) return;

                const t = this.phase === 'backward' ? (1 - this.progress) : this.progress;
                const x = lerp(this.x1, this.x2, t);
                const y = lerp(this.y1, this.y2, t);

                push();
                translate(x, y);

                // Glow effect based on phase - EXACT SAME STRUCTURE for both!
                if (this.phase === 'forward') {
                    // Forward: blue energy with white core
                    for (let r = this.size * 3; r > 0; r -= 2) {
                        const alpha = map(r, 0, this.size * 3, 0, 140) * this.life;
                        fill(180, 210, 255, alpha);  // Slightly richer blue
                        noStroke();
                        circle(0, 0, r);
                    }
                    // Core - pure white
                    fill(255, 255, 255, 200 * this.life);
                    circle(0, 0, this.size);
                } else {
                    // Backward: soft peachy orange with white core - SAME STRUCTURE!
                    for (let r = this.size * 3; r > 0; r -= 2) {
                        const alpha = map(r, 0, this.size * 3, 0, 130) * this.life;  // Brighter to match blue density
                        fill(235, 150, 120, alpha);  // Soft peachy orange
                        noStroke();
                        circle(0, 0, r);
                    }
                    // Core - pure white (identical to forward)
                    fill(255, 255, 255, 200 * this.life);
                    circle(0, 0, this.size);
                }

                // Directional arrow
                if (this.progress > 0.1 && this.progress < 0.9) {
                    const angle = atan2(this.y2 - this.y1, this.x2 - this.x1);
                    rotate(angle);

                    noFill();
                    if (this.phase === 'forward') {
                        stroke(255, 255, 255, 150 * this.life);
                    } else {
                        stroke(235, 150, 120, 150 * this.life);  // Softer orange for arrow too
                    }
                    strokeWeight(1);

                    // Arrow shape
                    line(-this.size, 0, this.size * 1.5, 0);
                    line(this.size * 1.5, 0, this.size * 0.8, -this.size * 0.5);
                    line(this.size * 1.5, 0, this.size * 0.8, this.size * 0.5);
                }

                pop();
            }

            isDead() {
                return this.life <= 0;
            }
        }

        function drawSynapses(fromPos, toPos, weights, phase, progress, layerName) {
            // Draw static connection lines first
            const sampleRate = layerName === 'input-hidden' ? 0.25 : 0.5;

            for (let i = 0; i < fromPos.length; i++) {
                for (let j = 0; j < toPos.length; j++) {
                    // Use deterministic selection based on indices + epoch
                    // Epoch provides variety during training, but stays frozen when paused
                    // This replaces random() to prevent flashing
                    const hash = (i * 73 + j * 37 + epoch * 7) % 100;
                    if (hash / 100 > sampleRate) continue;

                    const weight = weights[i] ? weights[i][j] : 0;
                    const absWeight = Math.abs(weight);

                    // Color based on sign and phase
                    const isPositive = weight > 0;
                    let baseColor;

                    if (currentPhase === 'forward') {
                        baseColor = isPositive ? color(106, 155, 204) : color(217, 119, 87);
                    } else {
                        // During backward, highlight which connections are transmitting gradients
                        baseColor = color(217, 119, 87);
                    }

                    // Alpha based on weight magnitude and user setting
                    const baseAlpha = map(absWeight, 0, 1, 20, 120) * params.synapseAlpha;

                    // Pulse effect during active phase
                    const pulseAlpha = currentPhase === phase ?
                        baseAlpha + sin(progress * PI) * 50 : baseAlpha;

                    // Thickness based on weight magnitude with pulse
                    const baseThickness = map(absWeight, 0, 1, 0.3, 2);
                    const thickness = currentPhase === phase ?
                        baseThickness + sin(progress * PI) * 0.5 : baseThickness;

                    stroke(red(baseColor), green(baseColor), blue(baseColor), pulseAlpha);
                    strokeWeight(thickness);

                    // Draw line
                    const x1 = fromPos[i].x;
                    const y1 = fromPos[i].y;
                    const x2 = toPos[j].x;
                    const y2 = toPos[j].y;

                    line(x1, y1, x2, y2);

                    // Add gradient overlay to show information flow direction
                    if (absWeight > 0.1) {
                        for (let k = 0; k < 5; k++) {
                            const t = k / 5;
                            const px = lerp(x1, x2, t);
                            const py = lerp(y1, y2, t);

                            let flowAlpha;
                            if (currentPhase === 'forward') {
                                flowAlpha = t * pulseAlpha * 0.3;
                            } else {
                                flowAlpha = (1 - t) * pulseAlpha * 0.3;
                            }

                            stroke(red(baseColor), green(baseColor), blue(baseColor), flowAlpha);
                            strokeWeight(thickness * (1 + t * 0.5));
                            point(px, py);
                        }
                    }
                }
            }

            // Manage flow particles
            // Particle system (only if enabled)
            if (params.showParticles) {
                if (isTraining && epoch < totalEpochs) {
                    // Training active - create new particles and update existing
                    // Remove dead particles
                    flowParticles = flowParticles.filter(p => !p.isDead());

                    // Add new particles occasionally for important connections
                    // Creation rate adjusts with animation speed to maintain consistent visual density
                    // When particles move slower, we create them less frequently
                    const baseInterval = 3;  // Base creation interval (frames)
                    const adjustedInterval = Math.max(1, Math.round(baseInterval / effectiveAnimationSpeed));

                    // Use trainingFrameCount instead of frameCount for consistent timing across pause/resume
                    if (trainingFrameCount % adjustedInterval === 0) {
                        for (let i = 0; i < fromPos.length; i++) {
                            for (let j = 0; j < toPos.length; j++) {
                                const weight = weights[i] ? weights[i][j] : 0;
                                const absWeight = Math.abs(weight);

                                // Only add particles for significant weights
                                // Use deterministic pseudo-random based on training frame for consistency
                                const particleHash = (i * 97 + j * 53 + trainingFrameCount * 31) % 1000;
                                if (absWeight > 0.2 && particleHash < 50) {  // ~5% chance
                                    const x1 = fromPos[i].x;
                                    const y1 = fromPos[i].y;
                                    const x2 = toPos[j].x;
                                    const y2 = toPos[j].y;

                                    flowParticles.push(new FlowParticle(x1, y1, x2, y2, currentPhase, weight));
                                }
                            }
                        }
                    }

                    // Update and draw particles
                    for (let particle of flowParticles) {
                        particle.update();
                        particle.display();
                    }
                } else if (epoch >= totalEpochs) {
                    // Training completed - let existing particles fade away naturally
                    flowParticles = flowParticles.filter(p => !p.isDead());
                    for (let particle of flowParticles) {
                        particle.update();  // Continue updating so they fade away
                        particle.display();
                    }
                    // Don't create new particles - they'll naturally disappear
                } else {
                    // Training paused - freeze particles in place
                    for (let particle of flowParticles) {
                        particle.display();  // Display only, no update = frozen in place
                    }
                }
            } else {
                // Checkbox unchecked - clear all particles
                flowParticles = [];
            }
        }

        function drawNeurons(positions, activations, gradients, layer) {
            for (let i = 0; i < positions.length; i++) {
                const pos = positions[i];
                const activation = activations[i] || 0;
                const gradient = gradients ? Math.abs(gradients[i] || 0) : 0;

                push();
                translate(pos.x, pos.y);

                // Phase transition effect - show both forward and backward interacting
                if (phaseProgress < 0.3) {
                    // Transitioning - show overlap
                    const transitionAlpha = map(phaseProgress, 0, 0.3, 100, 0);

                    // Previous phase lingering
                    const prevPhase = currentPhase === 'forward' ? 'backward' : 'forward';
                    if (prevPhase === 'backward' && gradient > 0) {
                        const haloSize = map(gradient, 0, 1, 0, 25) * params.glowIntensity;
                        for (let r = haloSize; r > 0; r -= 3) {
                            const alpha = map(r, 0, haloSize, transitionAlpha, 0);
                            fill(235, 150, 120, alpha);  // Softer peachy orange
                            noStroke();
                            circle(0, 0, r * 2);
                        }
                    } else if (prevPhase === 'forward' && activation > 0) {
                        const glowSize = map(activation, 0, 1, 5, 20) * params.glowIntensity;
                        for (let r = glowSize; r > 0; r -= 2) {
                            const alpha = map(r, 0, glowSize, transitionAlpha, 0);
                            fill(180, 210, 255, alpha);  // Richer blue to match particles
                            noStroke();
                            circle(0, 0, r * 2);
                        }
                    }
                }

                // Backward pass: Gradient halo (soft peachy orange)
                if (currentPhase === 'backward' && gradient > 0) {
                    const haloSize = map(gradient, 0, 1, 0, 40) * params.glowIntensity;

                    // Pulsing effect
                    const pulse = sin(phaseProgress * TWO_PI) * 0.2 + 1;

                    // Multi-layer gradient halo with softer colors (brighter to match blue)
                    for (let r = haloSize * pulse; r > 0; r -= 2) {
                        const alpha = map(r, 0, haloSize * pulse, 110, 0);  // Increased to match blue density
                        // Subtle color shift within peachy orange spectrum
                        const colorShift = map(r, 0, haloSize, 0, 20);
                        fill(235 + colorShift, 150 - colorShift/2, 120 - colorShift/2, alpha * phaseProgress);
                        noStroke();
                        circle(0, 0, r * 2);
                    }

                    // Add rotating gradient indicators with softer color
                    noFill();
                    stroke(235, 150, 120, 170 * phaseProgress);  // Increased brightness
                    strokeWeight(2);
                    const rotation = frameCount * 0.05;
                    for (let a = 0; a < TWO_PI; a += PI / 3) {
                        push();
                        rotate(rotation + a);
                        line(haloSize * 0.7, 0, haloSize * 1.2, 0);
                        pop();
                    }
                }

                // Forward pass: Activation glow (white/blue/yellow)
                if (currentPhase === 'forward') {
                    const glowSize = map(activation, 0, 1, 5, 35) * params.glowIntensity;

                    // Energy waves
                    const waveCount = 3;
                    for (let w = 0; w < waveCount; w++) {
                        const wavePhase = (phaseProgress + w / waveCount) % 1;
                        const waveSize = glowSize * (1 + wavePhase * 0.5);

                        for (let r = waveSize; r > 0; r -= 3) {
                            const alpha = map(r, 0, waveSize, 90, 0) * (1 - wavePhase);
                            // Richer blue-white gradient (matches particle color)
                            fill(180 + 75 * activation, 210 + 45 * activation, 255, alpha);
                            noStroke();
                            circle(0, 0, r * 2);
                        }
                    }
                }

                // Interaction sparkles when phase changes
                if (phaseProgress < 0.2 && activation > 0.3 && gradient > 0.1) {
                    const sparkleCount = 5;
                    for (let s = 0; s < sparkleCount; s++) {
                        const angle = (s / sparkleCount) * TWO_PI + frameCount * 0.1;
                        const dist = 20 + sin(phaseProgress * PI) * 10;
                        const sx = cos(angle) * dist;
                        const sy = sin(angle) * dist;

                        const sparkleSize = 2 + random(2);
                        const sparkleAlpha = map(phaseProgress, 0, 0.2, 200, 0);

                        fill(255, 200, 100, sparkleAlpha);
                        noStroke();
                        circle(sx, sy, sparkleSize);
                    }
                }

                // Neuron body with phase-dependent appearance
                const brightness = map(activation, 0, 1, 50, 255);

                if (currentPhase === 'forward') {
                    // Forward: bright, energetic (richer blue)
                    fill(brightness, brightness, 255);
                    stroke(180, 210, 255, 150);
                } else {
                    // Backward: warmer, processing (soft peachy orange)
                    fill(brightness * 0.9, brightness * 0.85, 255 * 0.95);
                    stroke(235, 150, 120, 150);
                }

                strokeWeight(2 + sin(phaseProgress * TWO_PI) * 0.5);
                circle(0, 0, 16);

                // Inner highlight
                noStroke();
                fill(255, 255, 255, 180);
                circle(-3, -3, 6);

                // Phase indicator ring
                noFill();
                if (currentPhase === 'forward' && activation > 0.5) {
                    stroke(255, 255, 255, 100);
                } else if (currentPhase === 'backward' && gradient > 0.3) {
                    stroke(255, 100, 50, 100);
                } else {
                    stroke(150, 150, 150, 50);
                }
                strokeWeight(1);
                circle(0, 0, 20);

                pop();
            }
        }

        function drawMetrics() {
            const metricsX = 1150;  // Moved further right to fit in wider canvas
            const metricsY = 50;
            const metricsWidth = 300;

            push();
            translate(metricsX, metricsY);

            // Title
            fill(20);
            noStroke();
            textSize(14);
            textAlign(LEFT);
            textFont('Poppins');
            text('Training Metrics', 0, 0);

            // Loss curve
            drawCurve(lossHistory, 'Loss', 0, 30, metricsWidth, 100,
                     color(217, 119, 87), true);

            // Accuracy curve
            drawCurve(accHistory, 'Accuracy', 0, 150, metricsWidth, 100,
                     color(106, 155, 204), false);

            // Gradient bars
            textSize(12);
            fill(20);
            text('Layer Gradients', 0, 280);

            if (network.hidden1Gradients.length > 0) {
                const avgHidden1Grad = network.hidden1Gradients.reduce((a, b) =>
                    a + Math.abs(b), 0) / network.hidden1Gradients.length;
                // Update max gradient for relative scaling
                maxHidden1Grad = Math.max(maxHidden1Grad, avgHidden1Grad);
                // Display relative bar (0-1 scaled to max seen)
                const relativeValue = avgHidden1Grad / maxHidden1Grad;
                drawGradientBar('Hidden1', avgHidden1Grad, relativeValue, 0, 300, metricsWidth, 20);
            }

            if (network.hidden2Gradients.length > 0) {
                const avgHidden2Grad = network.hidden2Gradients.reduce((a, b) =>
                    a + Math.abs(b), 0) / network.hidden2Gradients.length;
                maxHidden2Grad = Math.max(maxHidden2Grad, avgHidden2Grad);
                const relativeValue = avgHidden2Grad / maxHidden2Grad;
                drawGradientBar('Hidden2', avgHidden2Grad, relativeValue, 0, 330, metricsWidth, 20);
            }

            if (network.outputGradients.length > 0) {
                const avgOutputGrad = network.outputGradients.reduce((a, b) =>
                    a + Math.abs(b), 0) / network.outputGradients.length;
                maxOutputGrad = Math.max(maxOutputGrad, avgOutputGrad);
                const relativeValue = avgOutputGrad / maxOutputGrad;
                drawGradientBar('Output', avgOutputGrad, relativeValue, 0, 360, metricsWidth, 20);
            }

            // Current output probabilities (with more spacing from gradients)
            if (network.outputActivations.length > 0) {
                textSize(12);
                fill(20);
                text('Current Output', 0, 400);

                const probs = network.outputActivations;
                drawBar('Circle', probs[0], 0, 420, metricsWidth, 20, color(106, 155, 204));
                drawBar('Square', probs[1], 0, 450, metricsWidth, 20, color(120, 140, 93));
            }

            pop();
        }

        function drawCurve(data, label, x, y, w, h, col, invert = false) {
            push();
            translate(x, y);

            // Background
            fill(255);
            stroke(200);
            strokeWeight(1);
            rect(0, 0, w, h);

            // Label
            fill(20);
            noStroke();
            textSize(11);
            textAlign(LEFT);
            text(label, 5, 12);

            // Current value
            if (data.length > 0) {
                const current = data[data.length - 1];
                textAlign(RIGHT);
                text(current.toFixed(3), w - 5, 12);
            }

            // Draw curve
            if (data.length > 1) {
                noFill();
                stroke(col);
                strokeWeight(2);

                beginShape();
                for (let i = 0; i < data.length; i++) {
                    const px = map(i, 0, Math.max(data.length - 1, 1), 10, w - 10);
                    let val = data[i];
                    if (invert) val = Math.min(val, 2); // Clamp loss
                    const py = map(val, invert ? 2 : 0, invert ? 0 : 1, h - 10, 20);
                    vertex(px, py);
                }
                endShape();
            }

            pop();
        }

        function drawBar(label, value, x, y, w, h, col = color(217, 119, 87)) {
            push();
            translate(x, y);

            // Background
            fill(240);
            noStroke();
            rect(0, 0, w, h, 3);

            // Bar
            const barWidth = map(value, 0, 1, 0, w);
            fill(col);
            rect(0, 0, barWidth, h, 3);

            // Label
            fill(20);
            textSize(10);
            textAlign(LEFT);
            text(label, 5, h / 2 + 4);

            // Value with scientific notation for very small gradients
            textAlign(RIGHT);
            let displayValue;
            if (value < 0.0001 && value > 0) {
                // Use scientific notation for very small values
                displayValue = value.toExponential(2);
            } else {
                displayValue = value.toFixed(4);
            }
            text(displayValue, w - 5, h / 2 + 4);

            pop();
        }

        function drawGradientBar(label, actualValue, relativeValue, x, y, w, h, col = color(235, 150, 120)) {
            push();
            translate(x, y);

            // Background
            fill(240);
            noStroke();
            rect(0, 0, w, h, 3);

            // Bar based on RELATIVE value (0-1 scaled to max)
            const barWidth = map(relativeValue, 0, 1, 0, w);
            fill(col);
            rect(0, 0, barWidth, h, 3);

            // Label
            fill(20);
            textSize(10);
            textAlign(LEFT);
            text(label, 5, h / 2 + 4);

            // Display ACTUAL value with scientific notation for very small gradients
            textAlign(RIGHT);
            let displayValue;
            if (actualValue < 0.0001 && actualValue > 0) {
                // Use scientific notation for very small values
                displayValue = actualValue.toExponential(2);
            } else {
                displayValue = actualValue.toFixed(4);
            }
            text(displayValue, w - 5, h / 2 + 4);

            pop();
        }

        function drawPhaseIndicator() {
            push();

            // Position at top center
            const x = canvasWidth / 2;
            const y = 30;

            translate(x, y);

            // Background box
            const boxWidth = 600;
            const boxHeight = 70;

            fill(255, 255, 255, 230);
            stroke(currentPhase === 'forward' ? color(106, 155, 204) : color(235, 150, 120));
            strokeWeight(3);
            rect(-boxWidth/2, -boxHeight/2, boxWidth, boxHeight, 8);

            // Phase indicator
            noStroke();
            textAlign(CENTER);
            textFont('Poppins');

            if (currentPhase === 'forward') {
                // Forward pass explanation
                fill(106, 155, 204);
                textSize(16);
                textStyle(BOLD);
                text('⬆ FORWARD PASS', 0, -15);

                fill(60, 60, 60);
                textSize(11);
                textStyle(NORMAL);
                text('Processing batch through network → Computing predictions', 0, 5);

                // Progress bar
                const barWidth = 500;
                const barHeight = 8;
                fill(230, 230, 230);
                rect(-barWidth/2, 12, barWidth, barHeight, 4);

                fill(106, 155, 204, 200);
                rect(-barWidth/2, 12, barWidth * phaseProgress, barHeight, 4);

            } else {
                // Backward pass explanation (soft peachy orange)
                fill(235, 150, 120);
                textSize(16);
                textStyle(BOLD);
                text('⬇ BACKWARD PASS', 0, -15);

                fill(60, 60, 60);
                textSize(11);
                textStyle(NORMAL);
                text('Computing gradients → Updating all 1,346 weights', 0, 5);

                // Progress bar
                const barWidth = 500;
                const barHeight = 8;
                fill(230, 230, 230);
                rect(-barWidth/2, 12, barWidth, barHeight, 4);

                fill(235, 150, 120, 200);
                rect(-barWidth/2, 12, barWidth * phaseProgress, barHeight, 4);
            }

            pop();
        }

        function updateStats() {
            const stats = document.getElementById('stats');

            // Calculate current batch info
            totalBatches = Math.ceil(trainingData.length / params.batchSize);
            const percentComplete = (epoch / totalEpochs * 100).toFixed(1);

            stats.innerHTML = `
                Epoch: ${epoch} / ${totalEpochs} (${percentComplete}%)<br>
                Batch size: ${params.batchSize} samples<br>
                Loss: ${currentLoss.toFixed(4)}<br>
                Accuracy: ${(currentAcc * 100).toFixed(1)}%<br>
                Phase: ${currentPhase === 'forward' ? 'Forward ↑' : 'Backward ↓'}
            `;

            // Update diagnostics - proof of learning
            const diagnostics = document.getElementById('diagnostics');
            if (network && network.W2) {
                const currentWeight = network.W2[0][0];
                const initialWeight = initialWeights ? initialWeights.W2[0][0] : currentWeight;
                const weightChange = Math.abs(currentWeight - initialWeight);

                diagnostics.innerHTML = `
                    Total weight Δ: ${totalWeightChanges.toFixed(4)}<br>
                    Sample weight:<br>
                    W2[0][0] = ${currentWeight.toFixed(6)}<br>
                    Initial: ${initialWeight.toFixed(6)}<br>
                    Δ: ${weightChange.toFixed(6)}<br>
                    <small style="color: #788c5d;">Open browser console<br>for detailed logs</small>
                `;
            }

            // Update math display if enabled
            if (showMath && network && testData.length > 0) {
                updateMathDisplay();
            }
        }

        function updateMathDisplay() {
            const mathDisplay = document.getElementById('math-display');

            if (!network) return;

            let html = '';

            // Real-time training monitor - shows what's actually happening
            if (currentPhase === 'forward') {
                // FORWARD PASS - What you're seeing on screen
                html = `<div style="color: #6a9bcc; font-weight: bold; margin-bottom: 8px;">⬆ PREDICTION PHASE</div>`;

                // Count active neurons across both hidden layers
                let activeNeurons = 0;
                for (let i = 0; i < network.hidden1Activations.length; i++) {
                    if (network.hidden1Activations[i] > 0.1) activeNeurons++;
                }
                for (let i = 0; i < network.hidden2Activations.length; i++) {
                    if (network.hidden2Activations[i] > 0.1) activeNeurons++;
                }

                html += `<b>Network Activity:</b><br>`;
                html += `Active neurons: ${activeNeurons}/32<br>`;
                html += `Current loss: ${currentLoss.toFixed(4)}<br>`;
                html += `Confidence: ${(Math.max(...network.outputActivations) * 100).toFixed(1)}%<br>`;

                html += `<br><b>What's Flowing:</b><br>`;
                html += `White particles = data<br>`;
                html += `Bright glows = strong signals<br>`;
                html += `Making prediction...<br>`;

            } else {
                // BACKWARD PASS - What you're seeing on screen
                html = `<div style="color: #d97757; font-weight: bold; margin-bottom: 8px;">⬇ LEARNING PHASE</div>`;

                // Calculate gradient strength across both hidden layers
                let avgGrad = 0;
                let totalGrad = 0;
                let count = 0;
                if (network.hidden1Gradients.length > 0) {
                    totalGrad += network.hidden1Gradients.reduce((a, b) => a + Math.abs(b), 0);
                    count += network.hidden1Gradients.length;
                }
                if (network.hidden2Gradients.length > 0) {
                    totalGrad += network.hidden2Gradients.reduce((a, b) => a + Math.abs(b), 0);
                    count += network.hidden2Gradients.length;
                }
                if (count > 0) {
                    avgGrad = totalGrad / count;
                }

                // Weight change this epoch
                const recentChange = lossHistory.length >= 2 ?
                    Math.abs(lossHistory[lossHistory.length - 1] - lossHistory[lossHistory.length - 2]) : 0;

                html += `<b>Learning Dynamics:</b><br>`;
                // Use scientific notation for very small gradients
                const gradDisplay = avgGrad < 0.0001 && avgGrad > 0 ? avgGrad.toExponential(2) : avgGrad.toFixed(5);
                html += `Gradient strength: ${gradDisplay}<br>`;
                html += `Loss change: ${recentChange > 0 ? '-' : ''}${recentChange.toFixed(4)}<br>`;
                html += `Weights updated: 1,346<br>`;

                html += `<br><b>What's Flowing:</b><br>`;
                html += `Red particles = corrections<br>`;
                html += `Red halos = adjusting<br>`;
                html += `Network improving...<br>`;
            }

            // Training progress indicator
            const epochProgress = (epoch / totalEpochs * 100).toFixed(1);
            html += `<br><div style="padding-top: 8px; border-top: 1px solid #ddd; margin-top: 8px;">`;
            html += `<small style="color:#888;">Training: ${epochProgress}% complete</small>`;
            html += `</div>`;

            mathDisplay.innerHTML = html;
        }

        function toggleMathDisplay() {
            showMath = !showMath;
            const btn = document.getElementById('mathButton');
            btn.textContent = showMath ? '📊 Hide Monitor' : '📊 Show Monitor';

            if (!showMath) {
                document.getElementById('math-display').innerHTML =
                    'Click "Show Monitor" to see<br>live training dynamics';
            }
        }

        // ═══════════════════════════════════════════════════════════════════════
        // UI HANDLERS
        // ═══════════════════════════════════════════════════════════════════════

        function updateParam(paramName, value, requiresReset = false) {
            // Handle boolean values (checkboxes)
            if (['earlyStop', 'showSynapses', 'showParticles'].includes(paramName)) {
                params[paramName] = value;
                return;
            }

            // Parse numeric value
            params[paramName] = parseFloat(value);

            // Update display with appropriate formatting
            const displayElement = document.getElementById(paramName + '-value');
            if (displayElement) {
                if (paramName === 'learningRate') {
                    displayElement.textContent = parseFloat(value).toFixed(3);
                } else if (paramName === 'accuracyThreshold') {
                    displayElement.textContent = Math.round(parseFloat(value) * 100) + '%';
                } else if (paramName === 'trainingSpeed') {
                    displayElement.textContent = parseFloat(value).toFixed(1);
                } else if (['batchSize', 'dataSamples', 'maxEpochs', 'hiddenSize'].includes(paramName)) {
                    displayElement.textContent = parseInt(value);
                } else {
                    displayElement.textContent = parseFloat(value).toFixed(1);
                }
            }

            // Warn if this parameter requires training reset
            if (requiresReset) {
                console.log(`⚠️ ${paramName} changed - Click "Reset" to apply changes`);
            }
        }

        function toggleTraining() {
            isTraining = !isTraining;
            const btn = document.getElementById('trainButton');
            if (btn) {
                btn.textContent = isTraining ? '⏸ Pause' : '▶ Resume';
            }

            if (isTraining) {
                // Clear frozen cache when resuming
                frozenPredictions = null;
                frozenNetworkState = null;
            }

            console.log(`Training ${isTraining ? 'RESUMED' : 'PAUSED'}${!isTraining ? ' (UI frozen - complete freeze)' : ''}`);
        }

        function resetTraining() {
            initializeTraining();
            isTraining = true;
            frozenPredictions = null;  // Clear frozen cache
            frozenNetworkState = null;  // Clear frozen network state
            const btn = document.getElementById('trainButton');
            if (btn) {
                btn.textContent = '⏸ Pause';
            }
            console.log('Training RESET and STARTED');
        }

        function updateSeedDisplay() {
            document.getElementById('seed-input').value = params.seed;
        }

        function updateSeed() {
            let input = document.getElementById('seed-input');
            let newSeed = parseInt(input.value);
            if (newSeed && newSeed > 0) {
                params.seed = newSeed;
                resetTraining();  // Use resetTraining to properly reset all state
            } else {
                updateSeedDisplay();
            }
        }

        function previousSeed() {
            params.seed = Math.max(1, params.seed - 1);
            updateSeedDisplay();
            resetTraining();  // Use resetTraining to properly reset all state
        }

        function nextSeed() {
            params.seed = params.seed + 1;
            updateSeedDisplay();
            resetTraining();  // Use resetTraining to properly reset all state
        }

        function randomSeedAndUpdate() {
            params.seed = Math.floor(Math.random() * 999999) + 1;
            updateSeedDisplay();
            resetTraining();  // Use resetTraining to properly reset all state
        }

        function printDiagnostics() {
            console.log('\n========================================');
            console.log('FULL TRAINING DIAGNOSTICS');
            console.log('========================================');
            console.log('Seed:', params.seed);
            console.log('Current Epoch:', epoch);
            console.log('Learning Rate:', params.learningRate);
            console.log('Batch Size:', params.batchSize);
            console.log('\n--- NETWORK STATE ---');
            console.log('Loss:', currentLoss.toFixed(6));
            console.log('Accuracy:', (currentAcc * 100).toFixed(2) + '%');
            console.log('Total Weight Changes:', totalWeightChanges.toFixed(6));

            if (initialWeights && network) {
                console.log('\n--- WEIGHT COMPARISON (Sample) ---');
                console.log('Layer 2 Output Weight [0][0]:');
                console.log('  Initial:', initialWeights.W2[0][0].toFixed(8));
                console.log('  Current:', network.W2[0][0].toFixed(8));
                console.log('  Delta:', Math.abs(network.W2[0][0] - initialWeights.W2[0][0]).toFixed(8));

                console.log('\nLayer 2 Output Weight [0][1]:');
                console.log('  Initial:', initialWeights.W2[0][1].toFixed(8));
                console.log('  Current:', network.W2[0][1].toFixed(8));
                console.log('  Delta:', Math.abs(network.W2[0][1] - initialWeights.W2[0][1]).toFixed(8));

                console.log('\nBias term b2[0]:');
                console.log('  Initial:', initialWeights.b2[0].toFixed(8));
                console.log('  Current:', network.b2[0].toFixed(8));
                console.log('  Delta:', Math.abs(network.b2[0] - initialWeights.b2[0]).toFixed(8));
            }

            console.log('\n--- CURRENT ACTIVATIONS ---');
            if (network && testData.length > 0) {
                network.forward(testData[0].data);
                console.log('Hidden1 Layer (first 5):', network.hidden1Activations.slice(0, 5).map(x => x.toFixed(4)).join(', '));
                console.log('Hidden2 Layer (first 5):', network.hidden2Activations.slice(0, 5).map(x => x.toFixed(4)).join(', '));
                console.log('Output Layer:', network.outputActivations.map(x => x.toFixed(6)).join(', '));
                console.log('Predicted:', network.outputActivations[0] > network.outputActivations[1] ? 'Circle' : 'Square');
                console.log('Actual:', testData[0].type === 0 ? 'Circle' : 'Square');
            }

            console.log('\n--- GRADIENT MAGNITUDES ---');
            if (network && network.hidden1Gradients.length > 0) {
                const avgHidden1Grad = network.hidden1Gradients.reduce((a, b) => a + Math.abs(b), 0) / network.hidden1Gradients.length;
                console.log('Hidden1 Layer (avg):', avgHidden1Grad.toFixed(6));
            }
            if (network && network.hidden2Gradients.length > 0) {
                const avgHidden2Grad = network.hidden2Gradients.reduce((a, b) => a + Math.abs(b), 0) / network.hidden2Gradients.length;
                console.log('Hidden2 Layer (avg):', avgHidden2Grad.toFixed(6));
            }
            if (network && network.outputGradients.length > 0) {
                const avgOutputGrad = network.outputGradients.reduce((a, b) => a + Math.abs(b), 0) / network.outputGradients.length;
                console.log('Output Layer (avg):', avgOutputGrad.toFixed(6));
            }

            console.log('\n--- TRAINING HISTORY ---');
            console.log('Loss trajectory (last 10 epochs):', lossHistory.slice(-10).map(x => x.toFixed(4)).join(', '));
            console.log('Accuracy trajectory (last 10 epochs):', accHistory.slice(-10).map(x => (x * 100).toFixed(1) + '%').join(', '));

            if (predictionHistory.length > 0) {
                console.log('\n--- PREDICTION EVOLUTION ---');
                predictionHistory.forEach(p => {
                    console.log(`Epoch ${p.epoch}: [${p.output.map(x => x.toFixed(4)).join(', ')}] → ${p.output[0] > p.output[1] ? 'Circle' : 'Square'}`);
                });
            }

            console.log('\n--- TEST SET EVALUATION ---');
            const finalEval = evaluateNetwork();
            console.log('Test Loss:', finalEval.loss.toFixed(6));
            console.log('Test Accuracy:', (finalEval.acc * 100).toFixed(2) + '%');

            console.log('\n========================================');
            console.log('This is REAL training with REAL gradients.');
            console.log('Every weight shown above was updated via backpropagation.');
            console.log('Compare initial vs current weights to see the learning.');
            console.log('========================================\n');
        }

        // Initialize
        window.addEventListener('load', function() {
            updateSeedDisplay();
        });
    </script>
</body>
</html>
